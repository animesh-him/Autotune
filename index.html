<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AutoTune Pro</title>

<style>
body{
    background:#0d0d0d;
    color:white;
    font-family:Arial;
    text-align:center;
    padding:20px;
}
h2{
    font-size:22px;
}
input,button{
    font-size:18px;
    padding:10px;
    margin:10px;
}
progress{
    width:100%;
    height:20px;
}
audio{
    width:100%;
    margin-top:20px;
}
</style>
</head>

<body>

<h2>ðŸŽµ Auto Key Detect + AutoTune</h2>

<input type="file" id="fileInput" accept="audio/*"><br>

<button onclick="processAudio()">Detect & Tune</button>

<p id="status">Waiting for upload...</p>

<progress id="progressBar" value="0" max="100"></progress>

<audio id="player" controls></audio>

<script>

let audioContext = new (window.AudioContext || window.webkitAudioContext)();

function freqToMidi(freq){
    return 69 + 12*Math.log2(freq/440);
}

function midiToFreq(midi){
    return 440*Math.pow(2,(midi-69)/12);
}

// LIGHTWEIGHT autocorrelation (optimized)
function detectPitch(buffer, sampleRate){
    let SIZE = buffer.length;
    let maxSamples = Math.floor(SIZE/2);
    let bestOffset = -1;
    let bestCorrelation = 0;

    for(let offset=8; offset<maxSamples; offset++){
        let correlation = 0;

        for(let i=0; i<maxSamples; i++){
            correlation += Math.abs(buffer[i] - buffer[i+offset]);
        }

        correlation = 1 - (correlation/maxSamples);

        if(correlation > bestCorrelation){
            bestCorrelation = correlation;
            bestOffset = offset;
        }
    }

    if(bestCorrelation > 0.01){
        return sampleRate/bestOffset;
    }
    return -1;
}

function detectKey(pitches){
    let counts = new Array(12).fill(0);

    pitches.forEach(p=>{
        let midi = Math.round(freqToMidi(p));
        counts[midi%12]++;
    });

    return counts.indexOf(Math.max(...counts));
}

function buildMajorScale(root){
    let pattern=[0,2,4,5,7,9,11];
    return pattern.map(n=>(n+root)%12);
}

function nearestNote(midi, scale){
    let minDist=999;
    let best=midi;

    for(let octave=-2; octave<=2; octave++){
        scale.forEach(note=>{
            let candidate = note + octave*12;
            let dist = Math.abs(candidate - midi);
            if(dist < minDist){
                minDist = dist;
                best = candidate;
            }
        });
    }
    return best;
}

async function processAudio(){

    const file = document.getElementById("fileInput").files[0];
    if(!file) return alert("Upload audio first!");

    document.getElementById("status").innerText="Decoding audio...";
    document.getElementById("progressBar").value=10;

    const arrayBuffer = await file.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    const inputData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;

    const frameSize = 1024; // smaller = mobile friendly
    const hopSize = 1024;

    let pitches=[];
    let frames=[];

    document.getElementById("status").innerText="Analyzing pitch...";

    for(let i=0;i<inputData.length-frameSize;i+=hopSize){

        if(i % 50000 === 0){
            document.getElementById("progressBar").value = 
                20 + (i/inputData.length)*40;
            await new Promise(r=>setTimeout(r,1)); // prevent freeze
        }

        let frame = inputData.slice(i,i+frameSize);
        let freq = detectPitch(frame,sampleRate);

        if(freq>70 && freq<800){
            pitches.push(freq);
            frames.push({index:i, freq:freq});
        }
    }

    document.getElementById("status").innerText="Detecting key...";
    document.getElementById("progressBar").value=65;

    let root = detectKey(pitches);
    let scale = buildMajorScale(root);

    document.getElementById("status").innerText="Applying correction...";

    let output = new Float32Array(inputData.length);
    output.set(inputData);

    frames.forEach(f=>{
        let midi = freqToMidi(f.freq);
        let corrected = nearestNote(midi,scale);
        let ratio = midiToFreq(corrected)/f.freq;

        for(let j=0;j<frameSize;j++){
            let idx = f.index + j;
            if(idx < output.length){
                output[idx] *= ratio;
            }
        }
    });

    document.getElementById("progressBar").value=90;

    let newBuffer = audioContext.createBuffer(1, output.length, sampleRate);
    newBuffer.copyToChannel(output,0);

    let offlineCtx = new OfflineAudioContext(1, output.length, sampleRate);
    let source = offlineCtx.createBufferSource();
    source.buffer = newBuffer;
    source.connect(offlineCtx.destination);
    source.start();

    let rendered = await offlineCtx.startRendering();

    let wavBlob = new Blob([rendered.getChannelData(0)], {type:"audio/wav"});
    let url = URL.createObjectURL(wavBlob);

    document.getElementById("player").src = url;

    document.getElementById("progressBar").value=100;
    document.getElementById("status").innerText="Done!";

}

</script>

</body>
</html>
